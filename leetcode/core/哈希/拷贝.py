# Python中的拷贝：浅拷贝和深拷贝

# 1. 直接赋值（不是拷贝）
'''
直接赋值只是创建了一个新的引用，指向同一个对象
修改任何一个变量都会影响另一个
'''
list1 = [1, 2, [3, 4]]
list2 = list1  # 直接赋值
list2[0] = 9  # 修改list2会影响list1
print(list1)  # [9, 2, [3, 4]]
print(list2)  # [9, 2, [3, 4]]


# 2. 浅拷贝（Shallow Copy）
'''
浅拷贝会创建一个新对象，但它包含的是对原始对象中包含的对象的引用
对于不可变对象（如数字、字符串、元组），浅拷贝和深拷贝没有区别
对于可变对象（如列表、字典、集合），浅拷贝只复制第一层
'''
# 列表的浅拷贝方法
list1 = [1, 2, [3, 4]]
list2 = list1.copy()  # 方法1：使用copy()方法
list3 = list(list1)   # 方法2：使用list()构造函数
list4 = list1[:]      # 方法3：使用切片

# 字典的浅拷贝方法
dict1 = {'a': 1, 'b': [2, 3]}
dict2 = dict1.copy()  # 方法1：使用copy()方法
dict3 = dict(dict1)   # 方法2：使用dict()构造函数

# 集合的浅拷贝方法
set1 = {1, 2, 3}
set2 = set1.copy()    # 方法1：使用copy()方法
set3 = set(set1)      # 方法2：使用set()构造函数

# 浅拷贝的特点示例
list1 = [1, 2, [3, 4]]
list2 = list1.copy()  # 浅拷贝
list2[0] = 9          # 修改第一层，不会影响原列表
print(list1)          # [1, 2, [3, 4]]
print(list2)          # [9, 2, [3, 4]]

list2[2][0] = 9      # 修改第二层，会影响原列表
print(list1)          # [1, 2, [9, 4]]
print(list2)          # [9, 2, [9, 4]]


# 3. 深拷贝（Deep Copy）
'''
深拷贝会创建一个新对象，并递归地复制原始对象中包含的所有对象
完全独立于原始对象，修改任何一个都不会影响另一个
'''
import copy

# 列表的深拷贝
list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)  # 深拷贝

# 字典的深拷贝
dict1 = {'a': 1, 'b': [2, 3]}
dict2 = copy.deepcopy(dict1)  # 深拷贝

# 集合的深拷贝
set1 = {1, 2, 3}
set2 = copy.deepcopy(set1)    # 深拷贝

# 深拷贝的特点示例
list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)  # 深拷贝
list2[0] = 9                  # 修改第一层，不会影响原列表
print(list1)                  # [1, 2, [3, 4]]
print(list2)                  # [9, 2, [3, 4]]

list2[2][0] = 9              # 修改第二层，也不会影响原列表
print(list1)                  # [1, 2, [3, 4]]
print(list2)                  # [9, 2, [9, 4]]


# 4. 拷贝的应用场景
'''
1. 浅拷贝适用于：
   - 只需要复制第一层数据
   - 内部对象不需要独立副本
   - 性能要求较高（深拷贝较慢）

2. 深拷贝适用于：
   - 需要完全独立的副本
   - 内部对象也需要独立副本
   - 需要修改内部对象而不影响原对象

3. 注意事项：
   - 深拷贝比浅拷贝慢
   - 深拷贝可能会遇到循环引用问题
   - 对于不可变对象，浅拷贝和深拷贝效果相同
'''


# 5. 特殊情况：不可变对象的拷贝
'''
对于不可变对象（如数字、字符串、元组），浅拷贝和深拷贝没有区别
因为不可变对象一旦创建就不能修改，所以不需要创建新的副本
'''
# 元组的浅拷贝和深拷贝
tuple1 = (1, 2, 3)
tuple2 = tuple1[:]           # 浅拷贝
tuple3 = copy.deepcopy(tuple1)  # 深拷贝
print(tuple1 is tuple2)      # True
print(tuple1 is tuple3)      # True

# 字符串的浅拷贝和深拷贝
str1 = "hello"
str2 = str1[:]              # 浅拷贝
str3 = copy.deepcopy(str1)  # 深拷贝
print(str1 is str2)         # True
print(str1 is str3)         # True 


'''

直接赋值（不是拷贝）
   只是创建了一个新的引用，指向同一个对象
   修改任何一个变量都会影响另一个
浅拷贝（Shallow Copy）
      创建一个新对象，但只复制第一层
      对于嵌套对象，只复制引用
   方法：
   列表：list.copy(), list(), list[:]
   字典：dict.copy(), dict()
   集合：set.copy(), set()
深拷贝（Deep Copy）
   创建一个新对象，并递归地复制所有嵌套对象
   完全独立于原始对象
   使用 copy.deepcopy() 方法
主要区别：
   浅拷贝只复制第一层，深拷贝复制所有层
   浅拷贝中嵌套对象的修改会影响原对象，深拷贝不会
   深拷贝比浅拷贝慢，但更安全
特殊情况：
   对于不可变对象（数字、字符串、元组），浅拷贝和深拷贝效果相同
   因为不可变对象一旦创建就不能修改，所以不需要创建新的副本
使用场景：
   浅拷贝：当只需要复制第一层数据，且性能要求较高时
   深拷贝：当需要完全独立的副本，且需要修改内部对象时
'''


'''
   # 浅拷贝中第一层和深层的区别示例

# 示例1：嵌套列表
print("示例1：嵌套列表")
original = [1, 2, [3, 4], {'a': 5}]  # 包含数字、列表和字典的嵌套结构
shallow_copy = original.copy()        # 浅拷贝
deep_copy = copy.deepcopy(original)   # 深拷贝

print("原始数据:", original)
print("浅拷贝:", shallow_copy)
print("深拷贝:", deep_copy)
print("-" * 50)

# 1. 修改第一层（数字）
print("1. 修改第一层（数字）")
original[0] = 9
print("修改后 - 原始数据:", original)      # [9, 2, [3, 4], {'a': 5}]
print("修改后 - 浅拷贝:", shallow_copy)    # [1, 2, [3, 4], {'a': 5}]  # 不受影响
print("修改后 - 深拷贝:", deep_copy)       # [1, 2, [3, 4], {'a': 5}]  # 不受影响
print("-" * 50)

# 2. 修改深层（嵌套列表）
print("2. 修改深层（嵌套列表）")
original[2][0] = 9
print("修改后 - 原始数据:", original)      # [9, 2, [9, 4], {'a': 5}]
print("修改后 - 浅拷贝:", shallow_copy)    # [1, 2, [9, 4], {'a': 5}]  # ***受影响！
print("修改后 - 深拷贝:", deep_copy)       # [1, 2, [3, 4], {'a': 5}]  # 不受影响
print("-" * 50)

# 3. 修改深层（嵌套字典）
print("3. 修改深层（嵌套字典）")
original[3]['a'] = 9
print("修改后 - 原始数据:", original)      # [9, 2, [9, 4], {'a': 9}]
print("修改后 - 浅拷贝:", shallow_copy)    # [1, 2, [9, 4], {'a': 9}]  # ***受影响！
print("修改后 - 深拷贝:", deep_copy)       # [1, 2, [3, 4], {'a': 5}]  # 不受影响
print("-" * 50)

# 4. 添加新的深层元素
print("4. 添加新的深层元素")
original[2].append(5)
print("修改后 - 原始数据:", original)      # [9, 2, [9, 4, 5], {'a': 9}]
print("修改后 - 浅拷贝:", shallow_copy)    # [1, 2, [9, 4, 5], {'a': 9}]  # 受影响！
print("修改后 - 深拷贝:", deep_copy)       # [1, 2, [3, 4], {'a': 5}]  # 不受影响
print("-" * 50)


浅拷贝：
   一层：你复制了一个文件夹（创建新对象）->只是第一层是副本 一层之下的分支还是原始本
   深层：文件夹里的文件只是创建了快捷方式（复制引用）
而深拷贝则不同->创建全部数据的副本
   它会递归地复制所有层级
   每一层都创建全新的对象
   所以修改任何层级都不会相互影响

浅拷贝中第一层和深层的区别：

1. 第一层（直接元素）：
   - 浅拷贝会创建新的对象
   - 修改原始对象的第一层元素不会影响浅拷贝
   - 例如：修改 original[0] 不会影响 shallow_copy[0]

2. 深层（嵌套对象）：
   - 浅拷贝只复制引用，不创建新的对象
   - 修改原始对象的深层元素会影响浅拷贝
   - 例如：修改 original[2][0] 会影响 shallow_copy[2][0]

3. 为什么会有这种区别：
   - 浅拷贝只复制第一层，创建新的容器对象
   - 但容器内的对象（深层）只是复制了引用
   - 所以深层对象仍然是共享的

4. 深拷贝的区别：
   - 深拷贝会递归地复制所有层级的对象
   - 每一层都创建新的对象
   - 所以修改任何层级都不会相互影响

5. 实际应用中的注意事项：
   - 如果只需要独立的第一层数据，用浅拷贝
   - 如果需要完全独立的数据，包括嵌套对象，用深拷贝
   - 浅拷贝性能更好，但要注意深层数据的共享问题
'''

