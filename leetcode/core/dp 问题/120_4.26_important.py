# 三角形最小路径和
# 数组 动态规划

# 给定一个三角形 triangle ，找出自顶向下的最小路径和。
#
# 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是
# 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
# 也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
#

# 示例 1：
#
# 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
# 输出：11
# 解释：如下面简图所示：
#    2
#   3 4
#  6 5 7
# 4 1 8 3
# 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

# 示例 2：
#
# 输入：triangle = [[-10]]
# 输出：-10

# 路径存在负数


# 遍历每一层先取min的元素的索引然后计算和再到下一层在两个更小的一个里面做加得值  到下一层取下一层的min然后往上加取最小值
# 把两个比较取更小


# 实际也就是从底向上的更新 取更小 但是我的原代码的实现太复杂了 思路不够清晰
# 状态转移方程列对了 但是方法选混了 我用的是迭代但是是从上向下 这道题从上向下只能用递归
# 这种要用下一层和上一层对比得结果的都用倒推 可以避免重复计算简化代码
# 问：如何思考循环顺序？什么时候要正序枚举，什么时候要倒序枚举？
#
# 答：这里有一个通用的做法：盯着状态转移方程，想一想，要计算 f[i][j]，必须先把 f[i+1][j] 和 f[i+1][j+1] 算出来
# 那么只有 i 从大到小枚举才能做到，也就是需要后面一行的值来对比一定是逆序从底向上，对于 j 来说，正序倒序都可以。



# 有点区别是 简单的做法是计算从底到上的每条最小路径存在dp里最后取最小值  一层一层往上 每层都取两个元素的最小值 然后加上当前元素
from typing import List
import collections

# 我的乱七八糟的可以总结错误 但是不要当答案
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:

        # 初始化成最后一行的元素
        dp = triangle[-1].copy()
        # 如果不用copy()函数，直接使用dp = triangle[-1]，那么dp和triangle[-1]会指向同一个列表对象。这样当你修改dp时，triangle的最后一层也会被修改。
        # 让我解释一下为什么：
        # 在Python中，当你执行dp = triangle[-1]时，dp和triangle[-1]引用的是同一个列表对象。
        # 当你执行dp[j] = triangle[i][j] + min(dp[j], dp[j+1])时，你实际上是在修改这个共享的列表对象。
        # 这会导致triangle的最后一层被修改，因为dp和triangle[-1]指向同一个对象。
        # 使用copy()函数创建了一个新的列表对象，这样dp和triangle[-1]就是两个不同的对象，修改dp不会影响triangle。
        # 如果你不想使用copy()，还有其他几种方法可以避免修改原始数据：
        # 使用列表推导式：dp = [x for x in triangle[-1]]
        # 使用切片：dp = triangle[-1][:]
        # 使用list()函数：dp = list(triangle[-1])
        # 这些方法都会创建一个新的列表对象，而不是共享同一个引用。
        # 在你的代码中，使用copy()是最直接和清晰的方法，它明确表示你正在创建一个副本，而不是共享引用。

        for i in range(len(triangle)-2, -1, -1): # 遍历行 从倒数第二行开始
            dp[0] += triangle[i][0] # 第一列的元素和上一层的元素相加
            dp[len(triangle[-1])-1] += triangle[i][len(triangle[i])-1]
        # 倒推迭代
        for row in range(len(triangle)-2, -1, -1): #  遍历行 从倒数第二行开始
            for j in range(1,len(triangle[row])-1): # 遍历最后一列的元素 每次更新 但是对于两边的元素只能顺着往上走 也就是第一列和最后一列的元素和
                dp[j] +=  min(triangle[row][j], triangle[row][j-1]) # 更新底行元素的每条路径的最小值


        return min(dp)


# 自底向上的动态规划（你当前的解法）
# 特点：
# 从问题的子问题开始，逐步构建到最终问题
# 通常使用迭代（循环）而不是递归
# 按照一定的顺序计算所有子问题，确保计算某个问题时，****其依赖的子问题已经计算完成
# 在你的代码中：
# 从三角形的底部开始，逐层向上计算
# 使用一维数组dp存储中间结果
# 通过循环迭代计算每一层的最小路径和



# 记忆化搜索（Memoization）
# 特点：
# 是***自顶向下的***递归方法
# 使用记忆化技术避免重复计算
# 通常使用递归函数，并记录已计算过的子问题的结果
# 记忆化搜索的实现方式：
# 使用递归函数从顶部开始计算
# 使用一个缓存（通常是字典或数组）存储已计算过的子问题的结果
# 在递归过程中，先检查缓存中是否已有结果，如果有则直接返回，否则计算并存储


# 很好的思路 有非常普遍的用处
class Solution2:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        # 自底向上的动态规划
        n = len(triangle)
        # 使用一维数组dp来存储当前行的最小路径和
        dp = triangle[-1].copy()  # 初始化为最后一行的值

        # 从倒数第二行开始向上遍历
        for row in range(n - 2, -1, -1):
            # 对于当前行的每个元素
            for j in range(len(triangle[row])):
                # 当前元素加上下一行相邻两个元素中的较小值
                '''
                 这里非常重要 虽然是从底往上推 但是结果的计算还是加上下层的更小值 
                 这里就可以体现 dp存最后一层的用处 不只是为每个到达点保存最短路径 还能方便计算取更小值
                 这是非常典型的动态规划问题 还有就是方程很好列 但是通过什么思想实现方程也是很大的问题
                '''
                dp[j] = triangle[row][j] + min(dp[j], dp[j + 1])

        # 返回dp[0]，即从顶部到底部的最小路径和
        return dp[0]

# 递归 记忆化搜索
from functools import cache
class Solution3:

    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        # 递归边界（出口）：dfs(n−1,j)=triangle[n−1][j]。走到最后一排就无法再走了，路径上只有一个元素 triangle[n−1][j]。
        #
        # 递归入口：dfs(0,0)，这是原问题，也是答案。自上向下

        def dfs(i: int, j: int) -> int:
            if i == n - 1: # 出口 一般这里都要放出口的条件
                return triangle[i][j]

            # 对每个待计算位置调用递归函数
            # 下一行的两个元素里取更小 这个可以直接这样是因为第一行只有一个元素
            return min(dfs(i + 1, j), dfs(i + 1, j + 1)) + triangle[i][j] # 递归函数里的return要自己调用自己有自己的函数 同时还要有想要的结果方程

        return dfs(0, 0) # 外函数的return是进入递归的入口




triangle = [[-7],[-2,1],[-5,-5,9],[-4,-5,4,4],[-6,-6,2,-1,-5],[3,7,8,-3,7,-9],[-9,-1,-9,6,9,0,7],[-7,0,-6,-8,7,1,-4,9],[-3,2,-6,-9,-7,-6,-9,4,0],[-8,-6,-3,-9,-2,-6,7,-5,0,7],[-9,-1,-2,4,-2,4,4,-1,2,-5,5],[1,1,-6,1,-2,-4,4,-2,6,-6,0,6],[-3,-3,-6,-2,-6,-2,7,-9,-5,-7,-5,5,1]]

print(Solution().minimumTotal(triangle)) # 11
print(Solution2().minimumTotal(triangle)) # 11


