# dp 建立动态方程 状态转移方程

# 关键就是分析当前状态是有哪些可能得到的 列出方程

# 动态规划 用之前的状态更新得到当前的状态 每次都是由历史值得到的最佳结果
# 与贪心不同 贪心不顾历史结果 只顾当下的最优


# 1，记忆化搜索 正推 二维数组
# 2，优化 二维转一维只用列数的空间 只保留更新的状态 也就是把原本左边的状态更新到第一行的对应位置
# 3，递归 倒推
# 4，递推思想倒退 但是不设递归函数只归


# 1,迭代 每次计算都保证子问题完全解决 且只存储当前的结果
# 2,递归 每次计算都存储 最后一层一层返回 递归不只是从底向上
# 3,记忆化搜索也是每次都记录计算的结果 所以算是一种自顶向下的递归

# 递归搜索 + 保存递归返回值 = 记忆化搜索
考虑到整个递归过程中有大量重复递归调用（递归入参相同）。由于递归函数***没有副作用***非常关键的一点，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化


# 递归函数
        # 递归边界（出口）：dfs(n−1,j)=triangle[n−1][j]。走到最后一排就无法再走了，路径上只有一个元素 triangle[n−1][j]。
        #
        # 递归入口：dfs(0,0)，这是原问题，也是答案。自上向下

        def dfs(i: int, j: int) -> int:
            if i == n - 1: # 出口 一般这里都要放出口的条件
                return triangle[i][j]
            return min(dfs(i + 1, j), dfs(i + 1, j + 1)) + triangle[i][j] # 递归函数里的return要自己调用自己有自己的函数 同时还要有想要的结果方程

        return dfs(0, 0) # 外函数的return是进入递归的入口

# 一定从最后一个子问题开始试着列递归函数的 （return 方程）从退出的地方开始列
# 要对每个待计算的位置调用递归函数（用于理解递归方程的建立）
# 后面就是确认出入口 以及 出口条件

# ****调用递归函数可以直接视为结果来用 例如递归函数求前i个数的最大值 则直接可以直接调用dfs(i)来求解不要想其中的递归过程

# 状态机的设定




# 动态规划类型
# 1，序列dp
# 2，状态dp
# 3，背包dp


# 矩阵类型的状态更新也非常重要 矩阵类型题目中一个状态的更新会有两种选择
# 矩阵的状态更新 一般是从左到右或者从上到下 也就是从左边的状态更新到右边的状态 或者从上边的状态更新到下边的状态
# 可以优化空间 使保存状态的dp数组简化成一维