def identify():
    '''
        二分法就是把待取值框在一个范围里 (0,max) 
        然后在范围里用二分高效猜出最匹配的值

        算法题中识别二分法的关键特征：

        1. 看到"最小化最大值"或"最大化最小值"这类字眼
        例如：
        - "最小化每个工人的最大工作量"
        - "最大化最小速度"
        - "最小化最大等待时间"
        这类问题通常可以用二分答案来解决

        2. 看到"在...范围内查找"或"满足...条件的最小/最大值"
        例如：
        - "在[1,n]范围内查找缺失的第一个正整数"
        - "找到满足条件的最小速度"
        - "求满足条件的最小天数"
        这类问题往往暗示答案在某个范围内，可以用二分

        3. 看到"有序"、"单调"、"递增/递减"等关键词
        例如：
        - "有序数组"
        - "单调递增/递减"
        - "旋转有序数组"
        这类问题很可能需要二分

        4. 看到"O(log n)时间复杂度"的要求
        如果题目要求O(log n)的时间复杂度，很可能需要二分
        因为二分是达到O(log n)最常用的方法之一

        5. 看到"查找"、"搜索"等操作，且数据规模较大
        例如：
        - 在10^5或更大的数据规模中查找
        - 需要多次查找操作
        这类问题用二分可以显著提升效率

        实战技巧：
        1. 如果暴力解法是O(n)或更高，且数据规模较大(>10^4)，考虑二分
        2. 如果问题可以转化为"验证某个值是否满足条件"，考虑二分答案
        3. 如果问题具有单调性（满足条件的值一定在某个范围内），考虑二分
        4. 如果问题要求O(log n)时间复杂度，优先考虑二分
        5. 如果问题涉及"最小化最大值"或"最大化最小值"，很可能需要二分答案
        '''

def use():
    '''
        二分法的进阶应用：

        1. 二分答案 + 贪心
        例如：
        - 分配任务使最大工作量最小
        - 分配包裹使最大重量最小
        思路：
        1) 二分答案：猜测最大工作量/重量
        2) 贪心验证：尝试在限制下分配任务/包裹
        3) 根据验证结果调整二分范围

        2. 二分答案 + 动态规划
        例如：
        - 最小化最大子数组和
        - 最小化最大路径和
        思路：
        1) 二分答案：猜测最大和
        2) DP验证：计算是否能在限制下完成
        3) 根据DP结果调整二分范围

        3. 二分答案 + 双指针
        例如：
        - 找到最接近target的和
        - 找到满足条件的最短子数组
        思路：
        1) 二分答案：猜测目标值
        2) 双指针验证：检查是否存在满足条件的子数组
        3) 根据验证结果调整二分范围

        4. 二分答案 + 图论
        例如：
        - 最小化最大路径长度
        - 最小化最大边权
        思路：
        1) 二分答案：猜测最大长度/权值
        2) 图论算法验证：检查是否存在满足条件的路径
        3) 根据验证结果调整二分范围

        5. 二分答案 + 数学
        例如：
        - 求平方根
        - 求满足条件的最小整数
        思路：
        1) 二分答案：猜测目标值
        2) 数学方法验证：检查是否满足条件
        3) 根据验证结果调整二分范围

        二分法的常见陷阱：

        1. 边界条件处理
        - 注意left和right的初始值
        - 注意循环终止条件
        - 注意返回值的含义

        2. 整数溢出
        - 使用 left + (right - left) // 2 而不是 (left + right) // 2
        - 注意mid的计算方式

        3. 死循环
        - 确保每次循环区间都在收缩
        - 注意left和right的更新方式

        4. 精度问题
        - 处理浮点数时注意精度
        - 可能需要设置eps或使用整数计算

        5. 返回值处理
        - 注意返回left还是right
        - 注意是否需要-1或+1
        - 注意边界情况的处理
      '''

# 二分法模板 全闭可能造成死循环
def binary_search_first_less_equal(nums: list[int], target: int) -> int:
    """
    查找第一个小于等于target的数的索引
    使用左闭右开区间 [left, right)
    
    Returns:
        第一个小于等于target的数的索引，如果不存在返回-1
    """
    left, right = 0, len(nums)  # 左闭右开区间
    
    while left < right:  # 当left == right时退出 右边界取不到的写法
        mid = left + (right - left) // 2  # 防止整数溢出的写法***
        
        if nums[mid] <= target:
            # 如果当前值小于等于target，继续往右找 等于值在右边
            left = mid + 1
        else:
            # 如果当前值大于target，往左找
            right = mid # 右边界取不到 所以不用跳过（写mid+1）
    
    # 返回left-1，因为left指向的是第一个大于target的位置
    # 因为当判断nums[mid] <= target时，left = mid + 1，left指向第一个大于target的值，所以left-1才是第一个小于等于target的数
    return left - 1 if left > 0 else -1

def think():
    # 二分法理解

    '''
        二分法就是把待取值框在一个范围里 (0,max) 
        然后在范围里用二分高效猜出最匹配的值

        二分法的本质：缩小范围猜答案

        就像猜数字游戏：
        1. 对方心里想一个1-100的数字
        2. 你每次猜一个数，对方告诉你大了还是小了
        3. 根据反馈缩小范围继续猜
        4. 直到猜对为止

        二分法就是这种"猜数字"的算法化：
        1. 确定答案的范围 [left, right]
        2. 每次猜中间的数 mid = (left + right) // 2
        3. 根据条件判断答案在左半部分还是右半部分
        4. 缩小范围继续猜
        5. 直到找到答案

        为什么二分法高效？
        - 每次猜中间的数，可以排除一半的可能性
        - 比如1-100，第一次猜50，就能排除一半
        - 第二次猜25或75，又能排除一半
        - 这样每次都能快速缩小范围

        二分法的关键：
        1. 答案一定在某个范围内
        2. 可以判断答案在左半部分还是右半部分
        3. 每次都能排除一半的可能性

        就像玩猜数字游戏：
        - 范围：1-100
        - 第一次猜50，对方说大了
        - 范围缩小到1-49
        - 第二次猜25，对方说小了
        - 范围缩小到26-49
        - 以此类推，直到猜对

        二分法就是这种"猜数字"的算法化实现
    '''


def hide(): # 二分法在算法里的隐藏
    '''
        二段性用二分 target就是临界值 例如：在（0，target）不可完成 在[target，max）可完成

        # 让我通过一些经典的二分题目来分析其中隐藏的二段性：

        # 1. **旋转数组找最小值**：
        #    - 临界值：数组中的最小值 也就是猜的值 用二分法mid更新的值
        #    - 二段性：
        #      - 大于等于最小值的数：都大于等于最后一个数
        #      - 小于最小值的数：都小于最后一个数
        #    - 这让我们可以用最后一个数作为参考点进行二分

        # 2. **寻找峰值**：
        #    - 临界值：峰值点
        #    - 二段性：
        #      - 在峰值左边：nums[i] < nums[i+1]（上升）
        #      - 在峰值右边：nums[i] > nums[i+1]（下降）
        #    - 这让我们可以通过比较相邻元素来二分

        # 3. **在排序数组中查找元素的第一个和最后一个位置**：
        #    - 临界值：目标值的第一个位置和最后一个位置
        #    - 二段性：
        #      - 第一个位置：左边都小于目标值，右边都大于等于目标值
        #      - 最后一个位置：左边都小于等于目标值，右边都大于目标值

        # 4. **寻找重复数**：
        #    - 临界值：重复的数字
        #    - 二段性：
        #      - 小于重复数的数字：出现次数小于等于1
        #      - 大于等于重复数的数字：出现次数大于1

        # 5. **分割数组的最大值**：
        #    - 临界值：最小的最大子数组和
        #    - 二段性：
        #      - 小于临界值：无法分割成m个子数组
        #      - 大于等于临界值：可以分割成m个子数组

        # 6. **吃香蕉问题**：
        #    - 临界值：吃完所有香蕉的最小速度
        #    - 二段性：
        #      - 小于临界值：无法在规定时间内吃完
        #      - 大于等于临界值：可以在规定时间内吃完

        # 7. **供暖器问题**：
        #    - 临界值：最小的供暖半径
        #    - 二段性：
        #      - 小于临界值：无法覆盖所有房屋
        #      - 大于等于临界值：可以覆盖所有房屋

        # 8. **最小化最大值**：
        #    - 临界值：最小的可能最大值
        #    - 二段性：
        #      - 小于临界值：无法满足条件
        #      - 大于等于临界值：可以满足条件

        # 这些问题的共同特点：
        # 1. 都有一个明确的临界值
        # 2. 临界值前后有明显的性质区分
        # 3. 这种区分是单调的
        # 4. 可以通过二分法高效找到临界值

        # 识别二段性的技巧：
        # 1. 寻找问题中的"最小/最大"关键词
        # 2. 思考是否存在一个临界值
        # 3. 分析临界值前后的性质是否不同
        # 4. 判断这种区分是否单调

        # 当你在解题时，如果发现：
        # - 需要找一个满足条件的最小/最大值
        # - 存在一个临界值
        # - 临界值前后有明显的性质区分
        # - 这种区分是单调的

        # 那么这个问题很可能可以用二分法来解决。
    '''

def two(): # 二段性二分找临界值（用二分猜答案） check+二分循环调用check
    '''
        因为二段性二分的使用场景就是猜一个满足条件的目标值 所以能非常明确的归纳方法
    
        猜目标值 范围是[0,max+1)左闭右开写法 max是可能取值的最大值
        [0,ans)不满足 [ans,max+1)满足 来用二分法确定是哪个半表
        定义check函数 判断二分法的mid是否满足条件
        用二分法的mid更新来猜ans while->if check() 循环调用check判断

    '''
    from typing import List


    def check(ans:int,food:int):
        rest = food
        for p in people:
            if rest < p:
                return False
            rest -= p # 当前时间被吃掉的餐
            rest += ans # 当前时间生产的餐
        return True  
    
    def lowb(people:List[int],food:int)->int:
        left ,right = 0,max(people)+1 # 左闭右开
        while left < right:
            mid = (left + right) // 2
            if check(mid,food): # 当前满足条件 要找更小的所以缩到右半表 
                right = mid
            else: # 当前不满足条件 要找更大的所以缩到左半表
                left = mid + 1 # 左边界能取到且当前mid不满足 所以跳过 left返回的是第一个满足条件的值

        return left # 左边指向的是第一个满足条件的值



    time = int(input())
    food = int(input()) # 已有餐食
    people = list(map(int,input().split())) # 每个时间来的人数
    print(lowb(people,food))

